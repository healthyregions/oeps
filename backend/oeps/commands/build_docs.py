import os
import csv
from pathlib import Path
import subprocess

import click

from oeps.clients.bigquery import BigQuery
from oeps.clients.registry import Registry

from ._common_opts import (
    add_common_opts,
    registry_opt,
)


@click.command()
@click.argument(
    "operation",
)
@add_common_opts(registry_opt)
def build_docs(operation, registry_path):
    """Generates verious documentation pages based on the data content.

    OPERATION (choose one)

    bq-reference: build reference file for Big Query tables

    cli: create all documentation for the CLI interface

    registry-summary: build summary CSV files of all content in the registry

    """

    if operation == "bq-reference":
        client = BigQuery()
        registry = Registry(registry_path)

        outfile = Path("../docs/reference/big-query-tables.md").absolute().resolve()
        client.generate_reference_doc(registry.get_all_sources(), outfile)

    if operation == "cli":
        docs_path = Path("../docs/reference/commands")
        for path in docs_path.glob("*.md"):
            os.remove(path)

        ## list of base modules and commands to process
        command_list = [
            ("oeps.commands.bigquery_export", "bigquery_export"),
            ("oeps.commands.bigquery_upload", "bigquery_upload"),
            ("oeps.commands.build_docs", "build_docs"),
            ("oeps.commands.build_explorer_docs", "build_explorer_docs"),
            ("oeps.commands.build_explorer_map", "build_explorer_map"),
            ("oeps.commands.create_data_dictionaries", "create_data_dictionaries"),
            ("oeps.commands.inspect_csv", "inspect_csv"),
            ("oeps.commands.merge_data_table", "merge_data_table"),
            ("oeps.commands.validate_registry", "validate_registry"),
        ]

        for mod, com in command_list:
            mdclick_cmd = [
                "mdclick",
                "dumps",
                "--baseModule",
                mod,
                "--baseCommand",
                com,
                "--docsPath",
                docs_path,
            ]
            subprocess.run(mdclick_cmd)

        index_groups = set()
        paths = sorted([i for i in docs_path.glob("*.md") if not i.name == "README.md"])
        for path in paths:
            index_groups.add(path.stem.split("-")[0])

        index_content = [
            "# OEPS Backend -- CLI Commands\n\n",
            "The CLI provides the following groups of commands for managing OEPS data in different contexts.\n\n",
            "All of these commands must be invoked with the prefix `flask`, for example:\n\n",
            "```\nflask bigquery check-credentials\n```\n\n",
            "Use `--help` to get detailed information for each command, or look at the auto-generated documentation below.\n\n",
        ]
        for group in sorted(index_groups):
            index_content.append(f"- [{group}](./{group}.md)\n")
            for path in sorted(docs_path.glob(f"{group}-*.md")):
                subcommand = path.stem.replace(f"{group}-", "")
                index_content.append(f"  - [{subcommand}](./{path.stem}.md)\n")

        with open(docs_path / "README.md", "w") as o:
            o.writelines("".join(index_content))

        for path in docs_path.glob("*.md"):
            with open(path, "a") as o:
                o.write(
                    "\n_This documentation is automatically generated by "
                    "[md-click](https://github.com/RiveryIo/md-click). Do not edit this file directly._\n"
                )

    def generate_md_table(header, rows):
        content = "|".join(header) + "\n"
        content += "|".join(["-" for i in header]) + "\n"
        for row in rows:
            content += "|".join(row) + "\n"
        return content

    def write_csv_file(name, header, rows):
        path = Path(f"../docs/reference/registry/{name}.csv")
        with open(path, "w") as o:
            writer = csv.writer(o)
            writer.writerow(header)
            writer.writerows(rows)

    def clean_value(value, md=False):
        if isinstance(value, str):
            return value.replace("\n", "<br>")
        elif isinstance(value, list):
            join_char = "<br/>" if md else ", "
            return join_char.join(value)
        else:
            return str(value)

    if operation == "registry-summary":
        all_content_md = Path("../docs/reference/registry/all-content.md")

        registry = Registry()

        ## Create VARIABLES content

        variables = list(registry.variables.values())
        var_cols = [
            "name",
            "title",
            "type",
            "example",
            "description",
            "table_sources",
            "constraints",
            "construct",
            "source",
            "source_long",
            "oeps_v1_table",
            "comments",
            "metadata_doc_url",
            "longitudinal",
            "analysis",
        ]
        var_rows_csv = []
        var_rows_md = []
        for var in variables:
            var_rows_csv.append([clean_value(var[i]) for i in var_cols])
            var_rows_md.append([clean_value(var[i], md=True) for i in var_cols])

        ## Create THEME content

        themes = registry.themes
        theme_cols = ["theme", "construct", "proxy"]
        theme_rows = []

        for theme, constructs in themes.items():
            for construct, proxy in constructs.items():
                theme_rows.append([theme, construct, proxy])

        ## Create TABLE SOURCES content

        table_sources = list(registry.table_sources.values())
        tab_cols = [
            "name",
            "title",
            "path",
            "format",
            "mediatype",
            "description",
            "year",
            "geodata_source",
            "bq_dataset_name",
            "bq_table_name",
        ]
        tab_rows = []
        for var in table_sources:
            tab_rows.append([clean_value(var[i]) for i in tab_cols])

        ## Create GEODATA SOURCES content

        geodata_sources = list(registry.geodata_sources.values())
        geo_cols = [
            "name",
            "title",
            "path",
            "format",
            "mediatype",
            "description",
            "summary_level",
            "bq_dataset_name",
            "bq_table_name",
        ]
        geo_rows = []
        for var in geodata_sources:
            geo_rows.append([clean_value(var[i]) for i in geo_cols])

        write_csv_file("variables", var_cols, var_rows_csv)
        write_csv_file("themes", theme_cols, theme_rows)
        write_csv_file("table_sources", tab_cols, tab_rows)
        write_csv_file("geodata_sources", geo_cols, geo_rows)

        with open(all_content_md, "w") as o:
            o.write(f"""# Registry Content

    This is an autogenerated searchable list of all content in the registry.
    You can also access each section as a CSV if needed.

    Jump to:

    - [variables](#variables) [[csv](./variables.csv)]
    - [themes](#themes) [[csv](./themes.csv)]
    - [table_sources](#table_sources) [[csv](./table_sources.csv)]
    - [geodata_sources](#geodata_sources) [[csv](./geodata_sources.csv)]

    ## `variables`

    {generate_md_table(var_cols, var_rows_csv)}

    [back to top](#)

    ## `themes`

    {generate_md_table(theme_cols, theme_rows)}

    [back to top](#)

    ## `table_sources`

    {generate_md_table(tab_cols, tab_rows)}

    [back to top](#)

    ## `geodata_sources`

    {generate_md_table(geo_cols, geo_rows)}

    [back to top](#)

    _This file is automatically generated. Do not edit this file directly._
    """)
